{"version":3,"sources":["custom.mask.js"],"names":["BaseMask","getDefaultTranslation","val","replace","toPattern","value","mask","translation","result","maskCharIndex","valueCharIndex","length","maskChar","valueChar","translationHandler","resolverValue","DEFAULT_TRANSLATION","CustomMask","getType","getKeyboardType","getValue","settings","mergeSettings","masked","getRawValue","maskedValue","validate","validator"],"mappings":"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","sourcesContent":["import BaseMask from './_base.mask';\n\nfunction getDefaultTranslation() {\n  return {\n    '9': function (val) {\n      return val.replace(/[^0-9]+/g, '');\n    },\n    'A': function (val) {\n      return val.replace(/[^a-zA-Z]+/g, '');\n    },\n    'S': function (val) {\n      return val.replace(/[^a-zA-Z0-9]+/g, '');\n    },\n    '*': function (val) {\n      return val;\n    },\n  };\n}\n\nfunction toPattern(value, mask, translation) {\n  let result = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === mask.length) {\n      break;\n    }\n\n    // if value is ended, break.\n    if (valueCharIndex === value.length) {\n      break;\n    }\n\n    let maskChar = mask[maskCharIndex];\n    let valueChar = value[valueCharIndex];\n\n    // value equals mask, just set\n    if (maskChar === valueChar) {\n      result += maskChar;\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    // apply translator if match\n    const translationHandler = translation[maskChar];\n\n    if (translationHandler) {\n      const resolverValue = translationHandler(valueChar || '');\n      if (resolverValue === '') {\n        //valueChar replaced so don't add it to result, keep the mask at the same point and continue to next value char\n        valueCharIndex += 1;\n        continue;\n      } else if (resolverValue !== null) {\n        result += resolverValue;\n        valueCharIndex += 1;\n      } else {\n        result += maskChar;\n      }\n      maskCharIndex += 1;\n      continue;\n    }\n\n    // not masked value, fixed char on mask\n    result += maskChar;\n    maskCharIndex += 1;\n    continue;\n  }\n\n  return result;\n}\n\nconst DEFAULT_TRANSLATION = getDefaultTranslation();\n\nexport default class CustomMask extends BaseMask {\n  static getType() {\n    return 'custom';\n  }\n\n  static getDefaultTranslation() {\n    return getDefaultTranslation();\n  }\n\n  static shared = new CustomMask();\n\n  getKeyboardType() {\n    return 'default';\n  }\n\n  getValue(value, settings) {\n    if (value === '') {\n      return value;\n    }\n    let { mask } = settings;\n    let translation = this.mergeSettings(\n      DEFAULT_TRANSLATION,\n      settings.translation\n    );\n\n    var masked = toPattern(value, mask, translation);\n    return masked;\n  }\n\n  getRawValue(maskedValue, settings) {\n    if (!!settings && settings.getRawValue) {\n      return settings.getRawValue(maskedValue, settings);\n    }\n\n    return maskedValue;\n  }\n\n  validate(value, settings) {\n    if (!!settings && settings.validator) {\n      return settings.validator(value, settings);\n    }\n\n    return true;\n  }\n}\n"]}